'' =================================================================================================''''   File....... jm_sbus_tx__dev.spin2''   Purpose.... Futaba S.BUS encoder / transmitter''   Author..... Jon "JonnyMac" McPhalen''               Copyright (c) 2021 Jon McPhalen''               -- see below for terms of use''   E-mail..... jon.mcphalen@gmail.com''   Started....''   Updated.... 12 MAY 2021''''   {$P2}'''' ================================================================================================={   This code shows a process for determining the stack space requirements for a background Spin cog.   We start by specifying a large stack, filling it with a pattern, and then scanning through the   stack space -- top to bottom -- to look for changes in the pattern.   Credit to PhiPi from the forums for the concept of measuring actual stack usage. Once the stack   space is determined (and padded), the test code should be removed before the object is   deployed.   Start the cog and allow it to run while monitoring the stack usage.}con { fixed io pins }  PGM_RX = 63  { I }                                            ' programming / debug  PGM_TX = 62  { O }  SF_CS  = 61  { O }                                            ' serial flash  SF_SCK = 60  { O }  SF_SDO = 59  { O }  SF_SDI = 58  { I }con  STACK_SIZE = 128                                              ' start highvar  long  cog                                                     ' cog running s.bus tx  long  stack[STACK_SIZE]                                       ' stack for Spin cog  long  txp                                                     ' transmit pin  long  busyflag                                                ' cog is accessing channel array  word  channel[18]                                             ' channel inputs  byte  sbus[25]                                                ' s.bus outputspub null()'' This is not a top-level objectpub start(txpin, ms) : result | m, x'' Start S.BUS transmitter cog'' -- txpin is transmit pin'' -- ms is milliseconds in transmit loop  txp := txpin                                                  ' save tx pin  m := P_ASYNC_TX | P_INVERT_OUTPUT | P_OE                      ' S.BUS transmit  x := muldiv64(clkfreq, $1_0000, 100_000) & $FFFFFC00          ' set bit timing  x |= (10-1)                                                   ' set bits (10: 8 data, 1 parity, 1 extra stop)  pinstart(txp, m, x, 0)                                        ' start smart pin tx for S.BUS  x := clkfreq / 1000 * ms                                      ' ticks in S.BUS loop' Fill stack with pattern before runnning background' cog. Allow cog to run and then check on stack space' used with the stack_used() method. Remove test/dev' code when appropriate stack size is determined.  longfill(@stack, STACK_FILL, STACK_SIZE)' ---------------------------------------------------  cog := cogspin(NEWCOG, sbus_output(x), @stack) + 1            ' start the S.BUS cog  return cogcon { development }                                             ' remove before release  STACK_FILL = $AAAA_5555                                       ' use non-0 or non -1 patternpub stack_used() : n                                            ' remove before release  repeat n from STACK_SIZE-1 to 0                               ' scan stack from top to bottom    if (stack[n] <> STACK_FILL)                                 ' element modified?      return n+1                                                '  return stack usepub write(ch, value)'' Write channel (1..18) value'' -- use 2047 for "on" with ch17 and ch18'' -- check busy flag before use  if ((ch >= 1) && (ch <= 18))    channel[ch-1] := 0 #> value <# 2047pub is_busy() : result'' Returns true when cog is encoding S.BUS bytes  return busyflagpub address() : p_channels'' Returns address of channel[] array'' -- allows direct access  return @channelpri sbus_output(looptix) | t                                    ' this loop runs in cog  t := getct()  repeat    busyflag := true                                            ' disallow updates while encoding bytes    encode_sbus()                                               ' encode 18 channels into 23 bytes    busyflag := false                                           ' updates okay now    tx_sbus()                                                   ' send last packet    waitct(t += looptix)pri encode_sbus() | idx, ch, work, bc  idx := 1                                                      ' initialize locals  longfill(@ch, 0, 3)  sbus[0] := $0F                                                ' header byte  repeat while (idx <= 22)                                      ' encode 22 bytes    work |= (channel[ch++] << bc)                               ' get value, position, add to tmp    bc += 11                                                    ' update bit count    repeat while (bc >= 8)      sbus[idx++] := work.byte[0]                               ' save byte      work >>= 8                                                ' remove this byte from tmp      bc -= 8                                                   ' update bit count  sbus[23].[0] := channel[16].[10]                              ' set flag if >= 50%  sbus[23].[1] := channel[17].[10]  sbus[24] := 0                                                 ' footer bytepri tx_sbus() | i, b'' Transmit packed bytes to S.BUS'' -- adds even parity bit if necessary  repeat i from 0 to 24    b := sbus[i]                                                ' get s.bus byte    b.[8] := ones(b)                                            ' set parity bit    b.[9] := 1                                                  ' extra stop bit    wypin(txp, b)                                               ' send channel byte    repeat while (pinr(txp) == 0)                               ' let tx pin finishcon { license }{{  Terms of Use: MIT License  Permission is hereby granted, free of charge, to any person obtaining a copy of this  software and associated documentation files (the "Software"), to deal in the Software  without restriction, including without limitation the rights to use, copy, modify,  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to the following  conditions:  The above copyright notice and this permission notice shall be included in all copies  or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}